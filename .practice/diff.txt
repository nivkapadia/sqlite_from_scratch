--- ./main.c	2024-09-29 19:11:01.543768679 -0400
+++ ../main.c	2024-09-29 19:05:34.493902893 -0400
@@ -1,119 +1,283 @@
-/**
- * Here's how far the code has been implemented:
- * 
- *  - The code is able to take input from the console.
- *  - The code is able to parse the string.
- *  - 
- */
-
-
 #include <stdio.h>
-#include <stdbool.h>
 #include <stdlib.h>
-#include <string.h>
+#include <stdbool.h>
 #include <unistd.h>
+#include <stdint.h>
+#include <string.h>
 
-#define EXIT_FAILURE 1
 #define EXIT_SUCCESS 0
+#define EXIT_FAILURE 1
+#define size_of_attribute(Struct, Attribute) sizeof(((Struct *)0)->Attribute)
+
+#define COLUMN_USERNAME_SIZE 32
+#define COLUMN_EMAIL_SIZE 255
 
 typedef struct
 {
-    char *buffer;
-    size_t buffer_size;
-    size_t input_length;
+	char *buffer;
+	size_t buffer_length;
+	size_t input_length;
 } InputBuffer;
 
 typedef enum
 {
-    META_COMMAND_SUCCESS,
-    META_COMMAND_UNRECOGNIZED_COMMAND
+	META_COMMAND_SUCCESS,
+	META_COMMAND_UNRECOGNIZED_COMMAND
 } MetaCommandResult;
 
 typedef enum
 {
-    STATEMENT_INSERT,
-    STATEMENT_SELECT
+	PREPARE_SUCCESS,
+	PREPARE_UNRECOGNIZED_STATEMENT,
+	PREPARE_SYNTAX_ERROR
+} PrepareResult;
+
+typedef enum
+{
+	STATEMENT_INSERT,
+	STATEMENT_SELECT
 } StatementType;
 
 typedef struct 
 {
-    StatementType type;
+	uint32_t id;
+	char username[COLUMN_USERNAME_SIZE];
+	char email[COLUMN_EMAIL_SIZE];
+} Row;
+
+typedef struct
+{
+	StatementType type;
+	Row row_to_insert;
 } Statement;
 
-InputBuffer *init_buffer();
+typedef enum
+{
+	EXECUTE_SUCCESS,
+	EXECUTE_TABLE_FULL
+} ExecuteResult;
+
+typedef struct 
+{
+	uint32_t num_rows;
+	void *pages[TABLE_MAX_PAGES];
+} Table;
+
+ssize_t getline(char **lineptr, size_t *n, FILE *stream);
+InputBuffer *new_input_buffer();
+void *close_input_buffer(InputBuffer *input_buffer);
 void read_input(InputBuffer *input_buffer);
+void print_prompt();
 MetaCommandResult do_meta_command(InputBuffer *input_buffer);
+PrepareResult prepare_statement();
+ExecuteResult execute_statement(Statement *statement, Table *table);
+
+
+const uint32_t ID_SIZE = size_of_attribute(Row, id);
+const uint32_t USERNAME_SIZE = size_of_attribute(Row, username);
+const uint32_t EMAIL_SIZE = size_of_attribute(Row, email);
+const uint32_t ID_OFFSET = 0;
+const uint32_t USERNAME_OFFSET = ID_OFFSET + ID_SIZE;
+const uint32_t EMAIL_OFFSET = USERNAME_OFFSET + USERNAME_SIZE;
+const uint32_t ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;
+const uint32_t PAGE_SIZE = 4096;
+#define TABLE_MAX_PAGES 100
+const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;
+const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;
+void serialize_row(Row *source, void *destination);
+void deserialize_row(void *source, Row *destination);
+
 
-int main(void)
+
+int main(int argv, char *argc[])
 {
-    void print_prompt();
-    InputBuffer *input_buffer = init_buffer();
+	InputBuffer *input_buffer = new_input_buffer();
+
+	if (input_buffer == NULL)
+	{
+		puts("Error: Input Buffer Malloc Failed");
+		exit(1);
+	}
+
+	while (true)
+	{
+		print_prompt();
+		read_input(input_buffer);
+
+		if (input_buffer->buffer[0] == '.')
+		{
+			switch (do_meta_command(input_buffer))
+			{
+			case (META_COMMAND_SUCCESS):
+				continue;
+			case (META_COMMAND_UNRECOGNIZED_COMMAND):
+				printf("Unrecgonized command '%s'\n", input_buffer->buffer);
+				continue;
+			}
+		}
+
+		Statement statement;
+
+		switch (prepare_statement(input_buffer, &statement))
+		{
+		case (PREPARE_SYNTAX_ERROR):
+			printf("Syntax error in statement '%s'\n", input_buffer->buffer);
+			break;
+		case (PREPARE_SUCCESS):
+			break;
+		case (PREPARE_UNRECOGNIZED_STATEMENT):
+			printf("Unrecognized keyword at start of '%s'.\n'",
+				   input_buffer->buffer);
+			continue;
+		}
+
+		execute_statement(&statement);
+		printf("Executed.\n");
+	}
+}
 
-    while (true)
-    {
-        print_prompt();
-        read_input(input_buffer);
-
-        if (strcmp(input_buffer->buffer[0], ".") == 0)
-        {
-            switch (do_meta_command(input_buffer))
-            {
-            case (META_COMMAND_SUCCESS):
-                continue;
-            case (META_COMMAND_UNRECOGNIZED_COMMAND):
-                printf("Unrecognized command '%s'\n", input_buffer->buffer);
-                continue;
-            }
-        }
-
-        Statement statement;
-    }
-}
-
-InputBuffer *init_buffer()
-{
-    InputBuffer *input_buffer = (InputBuffer *)malloc(sizeof(InputBuffer));
-    if (input_buffer == NULL)
-    {
-        puts("Error: malloc for input_buffer failed");
-        exit(EXIT_FAILURE);
-    }
-
-    input_buffer->buffer = NULL;
-    input_buffer->input_length = 0;
-    input_buffer->buffer_size = 0;
+InputBuffer *new_input_buffer()
+{
+	InputBuffer *buffer = (InputBuffer *)malloc(sizeof(InputBuffer));
+	buffer->buffer = NULL;
+	buffer->buffer_length = 0;
+	buffer->input_length = 0;
 
-    return input_buffer;
+	return buffer;
 }
 
 void print_prompt()
 {
-    printf("> db $ ");
+	printf("> db$ ");
 }
 
 void read_input(InputBuffer *input_buffer)
 {
-    ssize_t read_bytes =
-        getline(&(input_buffer->buffer), &(input_buffer->buffer_size), stdin);
+	ssize_t bytes_read = getline(&(input_buffer->buffer), &(input_buffer->buffer_length), stdin);
 
-    if (read_bytes == -1)
-    {
-        printf("Read line failed\n");
-        exit(EXIT_FAILURE);
-    }
+	if (bytes_read <= 0)
+	{
+		puts("Error reading input");
+		exit(EXIT_FAILURE);
+	}
 
-    input_buffer->input_length = read_bytes - 1;
-    input_buffer->buffer[read_bytes - 1] = '\0';
+	input_buffer->input_length = bytes_read - 1;
+	input_buffer->buffer[bytes_read - 1] = 0;
+}
+
+void *close_input_buffer(InputBuffer *input_buffer)
+{
+	free(input_buffer->buffer);
+	free(input_buffer);
 }
 
 MetaCommandResult do_meta_command(InputBuffer *input_buffer)
 {
-    if (strcmp(input_buffer->buffer, ".exit") == 0)
-    {
-        exit(EXIT_SUCCESS);
-    }
-    else
-    {
-        return META_COMMAND_UNRECOGNIZED_COMMAND;
-    }
+	if (strcmp(input_buffer->buffer, ".exit") == 0)
+	{
+		exit(EXIT_SUCCESS);
+	}
+	else
+	{
+		return META_COMMAND_UNRECOGNIZED_COMMAND;
+	}
+}
+
+PrepareResult prepare_statement(InputBuffer *input_buffer, Statement *statement)
+{
+	if (strncmp(input_buffer->buffer, "insert", 6) == 0)
+	{
+		statement->type = STATEMENT_INSERT;
+
+		int args_assigned = sscanf(
+			input_buffer->buffer, "insert %d %s %s", &(statement->row_to_insert.id), &(statement->row_to_insert.username), &(statement->row_to_insert.email));
+
+		if (args_assigned < 3)
+		{
+			return PREPARE_SYNTAX_ERROR;
+		}
+		return PREPARE_SUCCESS;
+	}
+	if (strncmp(input_buffer->buffer, "select", 6) == 0)
+	{
+		statement->type = STATEMENT_SELECT;
+
+		// int args_assigned = sscanf(
+		// 	input_buffer->buffer, "select %d"
+		// );
+
+		return PREPARE_SUCCESS;
+	}
+
+	return PREPARE_UNRECOGNIZED_STATEMENT;
+}
+
+void execute_insert(Statement *statement, Table *table)
+{
+	if (table->num_rows >= TABLE_MAX_ROWS)
+	{
+		return EXECUTABLE_TABLE_FULL;
+	}
+
+	Row *row_to_insert = &(statement->row_to_insert);
+
+	serialize_row(row_to_insert, row_slot(table, table->num_rows));
+
+
+	table->num_rows++;
+	return EXECUTE_SUCCESS;
+}
+
+ExecuteResult execute_select(Statement *statement, Table *table)
+{
+	Row row;
+	for (uint32_t i = 0; i < table ->num_rows; i++)
+	{
+		deserialize_row(row_slot(table, i), &row);
+		print_row(&row);
+	}
+
+	return EXECUTE_SUCCESS;
+}
+
+ExecuteResult execute_statement(Statement *statement, Table *table)
+{
+	switch(statement->type)
+	{
+		case (STATEMENT_INSERT):
+			return execute_insert(statement, table);
+		case (STATEMENT_SELECT):
+			return execute_select(statement, table);
+		
+	}
+}
+
+void serialize_row(Row *source, void *destination)
+{
+	memcpy(destination + ID_OFFSET, &(source->id), ID_SIZE);
+	memcpy(destination + USERNAME_OFFSET, &(source->username), USERNAME_SIZE);
+	memcpy(destination + EMAIL_OFFSET, &(source->email), EMAIL_SIZE);
+}
+
+void deserialize_row(void *source, Row *destination)
+{
+	memcpy(&(destination->id), source + ID_OFFSET, ID_SIZE);
+	memcpy(&(destination->username), source + USERNAME_OFFSET, USERNAME_SIZE);
+	memcpy(&(destination->email), source + EMAIL_OFFSET, EMAIL_SIZE);
+}
+
+void *row_slot(Table *table, uint32_t row_num)
+{
+	uint32_t page_num = row_num / ROWS_PER_PAGE;
+
+	void *page  = table ->pages[page_num];
+
+	if (page == NULL)
+	{
+		page = table->pages[page_num] = malloc(PAGE_SIZE);
+	}
+
+	uint32_t row_offset = row_num % ROWS_PER_PAGE;
+	uint32_t byte_offset = row_offset * ROW_SIZE;
+	return page + byte_offset;
 }
\ No newline at end of file
